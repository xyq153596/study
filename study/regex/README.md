# 字符的匹配 
## 两种模糊匹配 
### 横向模糊 
* {m,n} 表示连续出现最少m次，最多n次 
* /ab{1,3}c/g => abc abbc abbbc 

### 纵向模糊 
* [123] 表示字符可以时 1，2，3到任何一种
* /a[123]b/g => a1b a2b a3b

## 字符组 
* 范围表示法
* 使用 - 来省略和简写 [1-6a-fG-M] => [123456abcdefGHIM]
* [-az] [az-] [a\-z] 来匹配 - a z
* [^abc] 表示除a b c 以外的字符
* \d -> [0-9] 表示数字
* \D -> [^0-9] 表示除数字
* \w -> [0-9a-zA-Z_] 表示单词字符
* \s -> [\t\v\n\r\f] 表示空白符
* \S -> [^\t\v\n\r\f] 表示非空白符
* . -> [^\n\r\u2028\u2029] 表示几乎任意字符
* [\d\D] [\w\W] [\s\S] [^] 表示任意字符 

## 量词 
* {m,} 至少出现m次
* {m} 出现m次
* ? -> {0,1} 表示出现或不出现
* + -> {1,} 表示至少出现一次
* * -> {0,} 表示出现任意次
* 贪婪匹配 表示尽可能的多的匹配 ／\d{2,5}/
* 懒惰匹配 表示尽可能的少的匹配 /\d{2,5}?/
* 在量词后面加上？ 可以实现惰性匹配 {m,n}? {m,}?

## 多选分支
* 使用|来分隔多个分支的匹配 (p1|p2|p3)
* /good|nice/g
* 注意:分支结构是惰性匹配

# 位置的匹配 
* ^ 匹配开头
* $ 匹配结尾
* ／^|$/g 单行 ／^|$/gm 多行
* \b 表示单词的边界，即\w和\W之间的位置，\w和^之间的位置，\w和$之间的位置。
* [js] lesson_01.mp4 -> ／\b/g => [#js#] #lesson_01#.#mp4#
* \D 表示非单词的边界
* (?=p) 其中p是一个子模式，表示p前面的位置。 (?=l),'#' 表示字母l前面的位置替换成# hello => he#l#lo 
* (?!p) 表示 (?=p)的相反意思
* 位置可以理解成空字符串

# 括号的作用 
## 分组和分支结构
* 分组：/(ab)+/g ab至少出现一次
* 分支：/(p1|p2)/g 

## 引用分组
* 提取数据
* /\d{4}-\d{2}-\d{2}/ -> /(\d{4})-(\d{2})-(\d{2})/ 得到括号里匹配到的值
* 2017-05-23 -> /(\d{4})-(\d{2})-(\d{2})/ => RegExp.$1='2017' RegExp.$2='06' RegExp.$3='23'
* 使用 string.match(regex) => ["2017-05-23","2017","05","23",index:0,input:"2017-05-23"] 
* 替换数据
* 将yyyy-mm-dd 替换成 mm/dd/yyyy
* string.replace(/(\d{4})-(\d2)-(\d2)/g,"$2/$3/$1")

## 反向引用
* 

## 非捕获分组
* (?:p) 

# 回溯原理 
* 当尝试匹配失败时，就会产生回溯，本质上就是深度优先算法
* 能造成回溯都地方有👇
* 贪婪量词
* 惰性量词
* 分支结构

# 拆分 
* 正则表达式结构
* 字面量 -> \d \n \. a
* 字符组 -> [0-9] [a-z] [^0-9]
* 量词 -> {0,2} a+ b*
* 锚点 -> ^ $ \b (?=p) 
* 分组 -> (ab)*
* 分支 -> p1|p2
* 反向引用 \1 \2 \3
* 涉及到的操作
* 转义符 \ 
* 括号和方括号 (...) (?=..) []
* 量词 {m,n} ? * +
* 位置和序列 ^ $ \1 
* 分隔符 |

# 构建 

# 编程 

# 总结
